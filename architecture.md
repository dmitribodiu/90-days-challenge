# ■■■ Day 6 
# Software architecture patterns >>>>>
# Layered architecture
Components within the layered architecture pattern are organized
into horizontal layers, each layer performing a specific role within
the application.
One of the powerful features of the layered architecture pattern is
the `separation of concerns` among components

## Key concepts
1. Layers of isolation
    Means that each layer can only impact layers that are directly besides it.
2. Opened layers
    Some layers (e.g service layers) can be open, meaning you don't need to 
    access them in order to access the layers below.

The layered architecture pattern is a solid general-purpose pattern,
making it a good starting point for most applications

## Drawbacks
1. architecture sinkhole anti-pattern
    When requests flow through multiple layers as simple pass-through 
    with little or no logic performed.
2. Layered architecutre tends to lend itself towards monolithic applications.
    It may cause problems for some applcations.

## Properties
1. Agility - low
    Cumbersome to make changes because of a monolithic nature of the pattern.
2. Ease of deployment - low
    Deployment may become an issue for larger apps.
    `Bad for CI pipeline`.
3. Testability - high
    Closed layers are easy to test because it's easy to mock other layers.
4. Performance - low
    Request has to go throught multiple layers which is not efficient.
5. Scalability - low
    Because of tightly couple tendency of this pattern, apps built with it are
    generally difficult to scale.
6. Ease of development - high
    Because layered structure mimics company specialists, it's a default choice 
    for most of companies.

# Event-driven architecture 
The event-driven architecture pattern is a popular distributed
asynchronous architecture pattern used to produce highly `scalable`
applications.

The event-driven architecture is made up of highly decoupled, single-purpose event
processing components that asynchronously receive and process events.

The event-driven architecture pattern consists of two main topologies,
the `mediator and the broker`.

## Mediator topology
The mediator topology is useful for events that have multiple steps
and require some level of orchestration to process the event.

There are four main types of architecture components within the
mediator topology: 
+ event queues
+ event mediator
+ event channels
+ event processors

There are two types of events within this pattern:
+ initial event
    original event received by mediator
+ processing event
    generated by the mediator and received by event processing components
    
For each step in the initial event, the event mediator sends out a specific
processing event to an event channel.

The `event processor` components contain the application business logic
necessary to process the processing event, they are idenpendent, `highly decoupled` 
components that perform a specific task in a system. Each processor should 
perform a single business task and not rely on other processors to complete their task.

## Broker
The broker topology differs from the mediator topology in that
there is no central event mediator, rather, the message flow is distributed
across the event processor components in a chain-like
fashion through a lightweight message broker. 

This topology is useful when you have a relatively
simple event processing flow

There are two main types of architecture components within the
broker topology: 
+ broker component 
+ event processor component.

The event channels contained within the broker component can be
message queues, message topics, or a combination of both.

the broker topology is all about the
`chaining of events to perform a business function`

once an event processor passes the event to another processor,
it is no longer involved with the processing of that specific event.

## Considerations
The event-driven architecture pattern is a relatively complex pattern to implement.
One consideration to take into account when choosing this architecture
pattern is the `lack of atomic transactions` for a single business process.

It is vitally important when
using this pattern to settle on a `standard data format` (XML/JSON)
and establish a contract versioning policy right from the start.

## Properties
1. Agility - high
    Since every process is completely decoupled from other processes, change can be made
    quickly.
2. Deployment - high
    Although broker is a little bit easier to deploy than mediator.
3. Testability - low
    You need special tool to generate events. Asynchronous nature of the pattern
    also adds up to the difficulty.
4. Performance - high
    Due to asynchronous nature is't very performant.
5. Scalability - high
    Each processor can be scaled separately which allows for fine-grained scalabiliyt.
6. Ease of development - low
    Why? 
    1. Async 
    2. Need for contract creation (JSON/XML scheme) 
    3. Complicated error handling of failed processors.

# Microkernel architecture
aka `plug-in` architecture pattern is a natural pattern for implementing
product-based applications (apps that are packaged and made available for download)

The microkernel architecture pattern allows you to add additional application
features as plug-ins to the core application, providing extensibility as well
as feature separation and isolation.

The microkernel architecture pattern consists of two types of components:
+ core system 
+ plug-in modules

The core system needs to know which plugins are available and how to get to them.
One way to implement that is through some sort of plug-in registry.
The patterns only specifies that these plugins should be independent from one another.

## Examples
Any IDE with plugins.
Browsers with plugins (Firefox, Chrome)

## Considerations
The microservices architecture pattern provides great support for
evolutionary design and incremental development. You can design the core system
and then as the app evolves add new features without having to make changes to the core
system.

For product-based applications, the microkernel architecture pattern
should always be your first choice. Particularly for products where you will be
releasing additional features and want control over which users get which features.

## Properties
1. Agility - high
    Changes can be isolated and implemented quickly via plug-ins.
2. Deployment - high
    Plugins can be added during runtime
3. Testability - high
    Plug-ins can be tested in isolation
4. Performance - high
    You can include only the plugins you need.
5. Scalability - medium
    Core system is not very scalable, although you can implement scalability on 
    the plug-in level
6. Ease Development - low
    This patterns requires thoughtful design and contract governance, making it 
    rather complex to implement.
    
# Microservices architecture pattern
Each component of this architecture is deployed as a separate unit.

`Service components` is an important notion in microservice architecture.
They contain one or more modules that represent either a single purpose function
or an independent portion of a large business app. 

Designing the right level of service component granularity is
one of the biggest challenges within a microservices architecture.

Another important notion is that microservices is a `distributed architecture`
all components are completely decoupled from one another and are accessed through 
some remote access protocol.

Microservices naturally evolved from layered architecutre and service-oriented 
pattern. This is the next step in patterns evolution.

When you deploy a monolitic application there's a high chance that something
will break. Wiht microservices on the other hand you can deploy more frequently 
and can have more confidence in release quality.

Microservices were designed to be easier than SOA to implement, it's attained
by simplifying connectivity and access to to service components.

## Topologies
In theory you can implement microservices however you want but 
the most common way to implement the patten is by using:
1. API REST based topology
    For websites with specific purposes. That contain of small services
    that implement some small self-contained portion of business logic.
2. application REST based topology
3. Centralized messaging topology
    Instead of using REST uses a `lightweight centralized message brocker`
    The `benefits` of this topology over the simple REST-based topology are:
    + advanced queuing mechanisms
    + asynchronous messaging
    + monitoring
    + error handling
    + better overall load balancing and scalability.
 
## Avoid dependencies and orchestration
One of the main challenges of the microservices architecture pattern
is determining the correct level of granularity for the service components.

If you find you need to orchestrate your components from user interface - your 
architecture is too fine-graned.
If you need to access multiple components within a single component - your components
are too large.

One way to prevent calling multiple components from within a component is 
to create a `shared database`. This way your services might have repeating 
code for database access, but it's a common practice,
you change redundancy of code for decoupling.

## Properties
1. Agility - high
    App built with this pattern tend to be very loosely coupled.
2. Ease of deployment - high
    Easy to deploy due to decoupled nature of pattern
3. Testability - high
    Due to separation of business logic into small components, they are easy to test.
4. Performance - low
    Due to distributed nature of the pattern it's usually not very performant.
5. Scalability - high
    Each component can be individually scaled.
6. Ease of development - high
    High decoupling -> easy development

# Space-based architecture (aka cloud architecture)
Usually architectures are hard to scale.
The space-based architecture pattern is specifically designed to
address and solve scalability and concurrency issues.

The space-based pattern (cloud architecture pattern)
minimizes the factors that limit application scaling

High scalability is achieved by removing the central database constraint and using
replicated in-memory data grids instead.
Because there is no central database, the database bottleneck is
removed, providing near-infinite scalability within the application.

The space-based architecture pattern is a complex and expensive
pattern to implement. It is a good architecture choice for smaller
web-based applications with variable load

However, it is not well suited for traditional
large-scale relational database applications with large amounts
of operational data.












































